//#include<iostream>
//
//using namespace std;
///*二叉树线索化：就是利用 有n个节点的二叉树，就会有n+1个空指针 这一特性，
//				用这些空指针来存放节点的前驱节点和后继节点
//	但是前驱节点和后继节点只有在遍历时才会出现，所以将二叉树线索化分为先序线索二叉树，中序线索二叉树，后序线索二叉树
//	如果该节点的左节点为空(左子树)，那么就将该节点的左指针指向遍历序列中它的前驱节点
//	如果该节点的右节点为空(右子树)，那么就将该节点的右指针指向遍历序列中它的后继节点
//	如果前驱节点的右指针为空，将前驱节点的右指针指向当前节点
//	如果当前节点的左指针为空，将当前节点的左指针指向前驱节点
//
//	先序线索二叉树求后继节点
//	方法：如果该节点的右指针存放的是线索，右指针指向的节点就是该节点的后继节点
//		  如果该节点的右指针存放的是节点，取左子节点，如果左子节点为空，则取右子节点 
//
//	后序线索二叉树求前驱节点
//	方法：如果该节点的左指针存放的是线索，右指针指向的节点就是该节点的前驱节点
//		  如果该节点的左指针存放的是节点，取右子节点，如果右子节点为空，则取左子节点
//
//	中序线索二叉树求后继节点和前驱节点
//	1>求后继节点方法：如果该节点的右指针存放的是线索，右指针指向的节点就是该节点的后继节点
//					  如果该节点的右指针存放的是节点，取右子树中序遍历序列的第一个(最左)节点既是该节点的后继节点
//	2>求前驱节点方法：如果该节点的左指针存放的是线索，左指针指向的节点就是该节点的前驱节点
//					  如果该节点的左指针存放的是节点，取左子树中序遍历序列的最后一个(最右)节点既是该节点的前驱节点
//*/
//
//// 线索二叉树的数据结构
//#define ElemType char
//
//typedef struct TBTNode
//{
//	ElemType data;// 存放节点的数据元素
//	TBTNode* left;// 存放节点的左指针（指向左子节点）
//	TBTNode* right;// 存放节点的右指针（只想右子节点）
//	unsigned char ltag, rtag;// 左右指针的类型，0 - 非线索指针, 1 - 线索指针
//}TBTNode;
//
//int main()
//{
//	
//	return 0;
//}
//
//
//void test1()
//{
//	double arr[] = { 0.01,0.15,0.12,0.03,0.02, 0.04,0.02,0.04,0.01,0.13,0.15,0.14,0.11,0.03 };
//	double h = 0;
//	for (int i = 0; i < 14; i++)
//	{
//		h += -(arr[i] * log2(arr[i]));
//	}
//	cout << h << endl;
//	cout << log2(0.7) << endl;
//
//	long long n = pow(16, 15);
//	cout << "n = " << n % 4371 << endl;
//}