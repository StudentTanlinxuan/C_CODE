#include<iostream>
#include<queue>
/*图的基本性质
* 在图型结构中，数据元素之间的关系是任意的，属于多对多关系。
* 在图中，数据元素一般被称为顶点(Vertex),简称V，是有穷非空集合，记为V = {v1,v2...vn},|V|表示顶点个数
* 两个顶点之间的关系称为边(Edge),简称E，是有穷集合，记为E = {(v1,v2),(v3,v2)|v1,v2,v3都属于V}
* 图简称为G,由顶点集V和边集E组成，记为G = (V,E)
* 无向图每条边都是无向边（没有方向），且之间的关系用 () 表示；
  有向图每条边都是有向边（有方向），且之间的关系用 <> 表示，且第一个为起始点，第二个为终端点
  有向边也称为弧，<V1,V2>称为从都顶点v1到顶点v2之间的弧。节点V1邻接到节点V2，或者节点V2邻接自V1
  无向图：顶点的度，与该顶点关联的边数。无向图中全部顶点的度之和等于边数乘以2
  有向图：1.入度：以该节点为终点的边的条数  2. 出度：以该节点为起始的边的条数
			顶点的度 = 该顶点入度 + 该节点的出度
			有向图中全部节点的入度之和等于全部节点的出度之和
* 
*/
/*图的存储结构
* 1. 邻接矩阵 顺序存储
* 2. 邻接表 顺序存储 + 链式存储
* 3. 十字链表 适用于有向图
* 4. 临接多重表  适用于无向图
* 
*/
// 图的数组表示法(邻接矩阵),一维数组表示图的顶点集V，二维数组表示图的边集E
#define MAXVNUM 100
typedef char VertType;

typedef struct
{
	VertType vexs[MAXVNUM]; // 表示顶点集V
	int edges[MAXVNUM][MAXVNUM]; // 表示边表(邻接矩阵)
	int vexnum, arcnum; // 定点数和边数
}MGraph;

// 邻接表(数组 + 链表)
// 顶点的结构体
typedef struct
{
	char data;// 顶点信息
	ENode* first;// 顶点的第一条边
}VNode;
// 边链表结构体
typedef char InfoType;
typedef struct
{
	int adjvex; // 边指向顶点的数组下标(伪指针)
	InfoType info; // 边相关的信息（权值）
	ENode* next; // 指向下一条边的指针
}ENode;
// 图的结构体
typedef struct
{
	VNode vexs[MAXVNUM]; // 顶点的数组
	int vexnum, arcnum; // 顶点数和边数
}Graph;
// 十字链表 (适合有向图)
// 临界多重表 (适合无向图)

/*图的遍历
* 1. 广度优先搜索(BFS)(相当于树的层次遍历)
*		广度优先遍历序列唯一不唯一？   
		主要看图采用的哪种存储结构，如果是邻接矩阵存储，则遍历序列是唯一的。
		如果采用邻接表存储，则遍历序列是不唯一的。
		因为邻接表后面存储边的边链表的各个节点是不唯一的。
* 2. 深度优先遍历(DFS)(相当于树的先序遍历)
* 因为图是有回路的，所以不管是BFS还是DFS都需要一个已访问数组visited[]
*/

/*图的应用
* 1.最小生成树
* 生成树：在无向连通子图中，包含全部顶点和极少连通子图
*			生成图包含原图全部顶点和n-1条边(多一条就会有回路，少一条就不是连通图)
* 普里姆算法(从顶点构建最小生成树)：
	从任意顶点开始构建生成树；然后依次将代价最小的其他顶点纳入最小生成树，直到所有顶点都纳入为止。
* 克鲁斯卡尔算法(从边构建最小生成树)：
	每次寻找权值最小的边，将边两端顶点连通，如果两个顶点已经连通，则不选。
   2. 最短路径
   最短路径的应用主要有两种：
   1> 单源最短路径：从某顶点出发，到其他全部顶点的最短路径。
		算法：1》广度优先算法(BFS)(无权图)
			  2》迪杰斯特拉算法(Dijkatra)(无权图，带权图) 注意：不适合权值为负数的图
				步骤：1. 初始化：1> 出发点是一个已经确定好最短路径的顶点
								 2> 更新于出发点有路径的顶点的最短路径和前驱顶点
					  2. 循环：1> 从未确定最短路径顶点中选取最短路径最小的顶点为新确定最短路径的顶点。
							   2> 更新与新确定最短路径的顶点有路径的顶点的最短路径和前驱顶点。(如果新路径更短再更新，更长则不更新)
   2> 顶点间的最短路径：全部(每对)顶点间的最短路径
		算法：1》弗洛伊德算法Floyd（无权图，带权图）适用权值为负数的图
				 使用Floyd算法，图的存储结构只能是邻接矩阵，不能是邻接表。且有两个矩阵，最短路径矩阵和中转矩阵。
				 最短路径矩阵初始化为邻接矩阵，中转矩阵初始化为-1。

			  步骤：弗洛伊德算法采用动态规划思想，分多个阶段解决问题。
					若图中有n个顶点(V0 - Vn-1),求途中每一对顶点间的最短路径需要分n个阶段
					0. 初始化，在没有其他顶点中转的情况下，求得各顶点间的最短路径。
					1. 如果在各顶点间增加一个V0作为中转顶点，求得各顶点间的新的最短路径。
					2. 再增加一个V1作为中转顶点，求得各顶点间的新的最短路径。
					3. 再再增加一个V2作为中转顶点，求得各顶点间的新的最短路径。
					...
					n. 最后再增加一个Vn-1作为中转顶点，求得各顶点间的最终最短路径。
   最短路径的计算结果包含两个方面：
   1> 从源顶点到目的顶点的路径长度 
   2> 从源顶点到目的顶点之间的路径(途径顶点的序列)
*/
/*拓扑排序:对一种特殊的图进行遍历。
* 实现：1. 从图中寻找一个没有前驱顶点(入度为0)的顶点输出。
*		2. 删除顶点和全部以它为起点的有向边
*		3. 重复1，2步骤，直到图为空
* AOV网(用顶点表示活动的网)：用顶点表示活动，用有向边(弧)表示活动时间先后关系的有向无环图
* 拓扑排序：表示做事先后顺序 
* AOE网：(用边表示活动的网)用顶点表示事件的发生，用有向边(弧)上的权值表示完成该活动所需要的开销(如完成活动所需的时间)的有向无环图
* AOE网有以下几个特点：
* 1. 图中只有一个入度为0的顶点，成为开始顶点(源点)，表示整个工程的开始。
* 2. 图中只有一个出度为0的顶点，成为结束顶点(汇点)，表示整个工程的结束。
* 3. 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始。
* 4. 只有在指向某顶点的各有向边所代表的活动全部都结束后，该顶点所代表的事件才能发生。
* 5. 在AOE网中，有些活动是可以并发进行的。
*/
using namespace std;

// 广度优先搜索算法求单源最短路径（从某顶点出发，到其他全部顶点的最短路径。）
bool visit[MAXVNUM]; // 标记各顶点是否被访问
int dist[MAXVNUM]; // 各顶点到起始顶点的最短路径，没有路径为-1
int path[MAXVNUM]; // 前驱顶点，没有前驱顶点为-1

void BFSMinDist(Graph g, VNode v)
{
	// 初始化
	for (int i = 0; i < MAXVNUM; i++)
	{
		visit[i] = false;
		dist[i] = -1;
		path[i] = -1;
	}
	queue<VNode> q;
	dist[0] = 0; // 顶点最短路径为0
	visit[0] = true; // 顶点v已访问
	q.push(v); // 起始顶点入队
	while (!q.empty())
	{
		VNode vu = q.front();
		int u = vu.data;
		q.pop(); 
		// 伪代码
		//// 探索u顶点的每一条边
		//for (int w = FirstAdjVex(G, u); w >= 0; w = NextAdjVex(G, u, w))
		//{
		//	if (visit[w] == false)
		//	{
		//		visit[w] = true; // 顶点w已访问
		//		dist[w] = dist[u] + 1; // 顶点w路径长度在u的基础上加一
		//		path[w] = u;// 顶点w的前驱元素为u
		//		q.push(w);// 顶点w入队
		//	}
		//}
	}
}
int main()
{

	return 0;
}