//#include<iostream>
//
//using namespace std;
//// 树节点的度：就是该节点孩子节点的个数
//// 节点的路径：从一个节点到另一个节点所经过的边数
//// 节点的权：节点的数值
//// 节点的带权路径长度：从根节点到该节点的路径长度和该店权值的乘积
//// 树的带权路径长度：为树中所有叶子节点的带权路径之和(WPL)
//// 在含有n个带权叶节点的二叉树中，WPL(树的带权路径长度)值最小的二叉树被称为哈夫曼树。哈夫曼树并不唯一
//// 构造哈夫曼树
//// 1. 初始节点都会成为叶子节点，叶节点的权值最大，离根节点最近
//// 2. 如果叶节点共有n个，共合并n-1次，哈夫曼树的总结点数为2n-1。
//// 3. 哈夫曼树不存在度为1的节点
//// 4. 哈夫曼树并不唯一，只要WPL最小就行	
//// 构造哈夫曼树时：从下往上构造，将每个节点看成一棵树，先找两个权值最小的合并，再将合并后的树与其他树做比较，重复前面步骤。直到将所有树全部合并成一棵树。
//// KMP算法，模式串指针回溯到不相等字符前模式串最长公共前后缀长度加一，再比较
//// 采用kmp算法，查找在目标串sstr中模式串tstr出现的位置，字符串的起始位置从0开始。
//int main()
//{
//	
//	return 0;
//}